From e966732f28a305387e2b9f4b0f230671e942351e Mon Sep 17 00:00:00 2001
From: Ian Barwick <barwick@gmail.com>
Date: Mon, 26 May 2025 23:23:48 +0900
Subject: [PATCH] Fix some further compiler warnings

With "-Wstringop-truncation", the compiler is fretting about a
possible missing terminating NUL character, even though we explicitly
set that immediately after the strncpy call.

Initializing the entire buffer with NUL characters before calling
strncpy makes the issue go away.

Per report in GitHub #8.
---
 src/libfq.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/src/libfq.c b/src/libfq.c
index 539e2fd..7dd2e05 100644
--- a/src/libfq.c
+++ b/src/libfq.c
@@ -294,8 +294,8 @@ FQconnectdbParams(const char * const *keywords,
 	/* store database path */
 	db_path_len = strlen(db_path);
 	conn->db_path = malloc(db_path_len + 1);
-	strncpy(conn->db_path, db_path, db_path_len);
-	conn->db_path[db_path_len] = '\0';
+	memset(conn->db_path, '\0', db_path_len + 1);
+	strncpy(conn->db_path, db_path, db_path_len + 1);
 
 	/* set and store other parameters */
 	if (uname != NULL)
@@ -305,8 +305,8 @@ FQconnectdbParams(const char * const *keywords,
 		isc_modify_dpb(&dpb, &conn->dpb_length, isc_dpb_user_name, uname, uname_len);
 
 		conn->uname = malloc(uname_len + 1);
-		strncpy(conn->uname, uname, uname_len);
-		conn->uname[uname_len] = '\0';
+		memset(conn->uname, '\0', uname_len + 1);
+		strncpy(conn->uname, uname, uname_len + 1);
 	}
 
 	if (upass != NULL)
@@ -316,8 +316,8 @@ FQconnectdbParams(const char * const *keywords,
 		isc_modify_dpb(&dpb, &conn->dpb_length, isc_dpb_password, upass, upass_len);
 
 		conn->upass = malloc(upass_len + 1);
-		strncpy(conn->upass, upass, upass_len);
-		conn->upass[upass_len] = '\0';
+		memset(conn->upass, '\0', upass_len + 1);
+		strncpy(conn->upass, upass, upass_len + 1);
 	}
 
 	/*
From 809ef0bccfb0c6b8cd2852adf4777d7f45dc577f Mon Sep 17 00:00:00 2001
From: Ian Barwick <barwick@gmail.com>
Date: Fri, 18 Apr 2025 18:39:26 +0900
Subject: [PATCH] Update boolean handling for C23 standard

There was a reason for manually defining a boolean type, possibly
because back in the day (12 years or so ago) it was what PostgreSQL
itself did, but C is now far enough into the 21st century that it
seems reasonable to assume <stdbool.h> is universally available.

See also PostgreSQL core commit bc5a4dfcf73.

GitHub #8.
---
 include/libfq.h | 25 +------------------------
 1 file changed, 1 insertion(+), 24 deletions(-)

diff --git a/include/libfq.h b/include/libfq.h
index 7e37e99..31a39ed 100644
--- a/include/libfq.h
+++ b/include/libfq.h
@@ -2,35 +2,12 @@
 #define LIBFQ_H
 
 #include <stdlib.h>
+#include <stdbool.h>
 #include <ibase.h>
 
 #ifndef C_H
 #define C_H
 
-
-#ifndef BOOL
-#define BOOL
-typedef char bool;
-
-
-#ifndef true
-#define true    ((bool) 1)
-#endif
-
-#ifndef false
-#define false   ((bool) 0)
-#endif
-
-typedef bool *BoolPtr;
-
-#ifndef TRUE
-#define TRUE    1
-#endif
-
-#ifndef FALSE
-#define FALSE   0
-#endif
-#endif
 /*
  * lengthof
  *              Number of elements in an array.
From bf8f6112c032c8d464ac8ac2b50d71a24a17ce61 Mon Sep 17 00:00:00 2001
From: Ian Barwick <barwick@gmail.com>
Date: Fri, 18 Apr 2025 19:02:26 +0900
Subject: [PATCH] Miscellaneous code cleanup

Addresses various compiler warnings, including those noted in GitHub #8.
---
 src/libfq.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/libfq.c b/src/libfq.c
index fd60a26..539e2fd 100644
--- a/src/libfq.c
+++ b/src/libfq.c
@@ -26,6 +26,7 @@
 
 #include <stdio.h>
 #include <string.h>
+#include <strings.h>
 #include <stdlib.h>
 #include <stdint.h>
 #include <sys/time.h>
@@ -3658,7 +3659,7 @@ _FQformatDatum(FBconn *conn, FQresTupleAttDesc *att_desc, XSQLVAR *var)
 			if (var->sqlsubtype == 1)
 			{
 				/* column defined as "CHARACTER SET OCTETS" */
-				p = _FQformatOctet(vary2->vary_string, vary2->vary_length);
+				p = _FQformatOctet((char *)vary2->vary_string, vary2->vary_length);
 			}
 			else
 			{
@@ -3708,7 +3709,7 @@ _FQformatDatum(FBconn *conn, FQresTupleAttDesc *att_desc, XSQLVAR *var)
 
 				if (value >= 0)
 				{
-					p = (char *)malloc(buflen);
+					p = (char *)malloc(buflen + 1);
 					sprintf(p, "%lld.%0*lld",
 							(ISC_INT64) value / tens,
 							-dscale,
